// Copyright (c) 2016 Palantir Technologies Inc. All rights reserved.
// Use of this source code is governed by the Apache License, Version 2.0
// that can be found in the LICENSE file.

package amalgomate

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"

	"github.com/pkg/errors"
)

func Run(cfg Config, outputDir, pkg string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return errors.Wrapf(err, "failed to ensure that output directory exists: %s", outputDir)
	}

	if !filepath.IsAbs(outputDir) {
		wd, err := os.Getwd()
		if err != nil {
			return errors.Wrapf(err, "failed to get working directory")
		}
		outputDir = path.Join(wd, outputDir)
	}

	// repackage main files specified in configuration
	if err := repackage(cfg, outputDir); err != nil {
		return errors.Wrapf(err, "failed to repackage files specified in configuration")
	}

	amalgomatedOutputDir := path.Join(outputDir, internalDir)

	// write output file that imports and uses repackaged files
	if err := writeOutputGoFile(cfg, outputDir, amalgomatedOutputDir, pkg); err != nil {
		return errors.Wrapf(err, "failed to write output file")
	}

	return nil
}

const (
	mainTemplate = `// generated by amalgomate; DO NOT EDIT
package main

import (
	"fmt"
	"os"
	"sort"
)

var programs = map[string]func() {
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Missing program argument. Valid values:", cmds())
		os.Exit(1)
	}

	programName := os.Args[1]
	if _, ok := programs[programName]; !ok {
		fmt.Printf("Unknown program: \"%v\". Valid values: %v\n", programName, cmds())
		os.Exit(1)
	}

	os.Args = append([]string{os.Args[0]}, os.Args[2:]...)
	programs[programName]()
}

func cmds() []string {
	var cmds []string
	for key := range programs {
		cmds = append(cmds, key)
	}
	sort.Strings(cmds)
	return cmds
}
`
	libraryTemplate = `// generated by amalgomate; DO NOT EDIT
package amalgomated

import (
	"fmt"
	"sort"
)

var programs = map[string]func() {
}

func Instance() Amalgomated {
	return &amalgomated{}
}

type Amalgomated interface {
	Run(cmd string)
	Cmds() []string
}

type amalgomated struct{}

func (a *amalgomated) Run(cmd string) {
	if _, ok := programs[cmd]; !ok {
		panic(fmt.Sprintf("Unknown command: \"%v\". Valid values: %v", cmd, a.Cmds()))
	}
	programs[cmd]()
}

func (a *amalgomated) Cmds() []string {
	var cmds []string
	for key := range programs {
		cmds = append(cmds, key)
	}
	sort.Strings(cmds)
	return cmds
}
`
)

func writeOutputGoFile(config Config, outputDir, amalgomatedOutputDir, packageName string) error {
	fileSet := token.NewFileSet()

	var template string
	if packageName == "main" {
		template = mainTemplate
	} else {
		template = libraryTemplate
	}

	file, err := parser.ParseFile(fileSet, "", template, parser.ParseComments)
	if err != nil {
		return errors.Wrapf(err, "failed to parse template: %s", template)
	}
	file.Name = ast.NewIdent(packageName)

	if err := addImports(file, fileSet, amalgomatedOutputDir, config); err != nil {
		return errors.Wrap(err, "failed to add imports")
	}
	sortImports(file)

	if err := setVarCompositeLiteralElements(file, "programs", createMapLiteralEntries(config.Pkgs)); err != nil {
		return errors.Wrap(err, "failed to add const elements")
	}

	// write output to in-memory buffer and add import spaces
	var byteBuffer bytes.Buffer
	if err := printer.Fprint(&byteBuffer, fileSet, file); err != nil {
		return errors.Wrap(err, "failed to write output file to buffer")
	}
	outputWithSpaces := addImportSpaces(&byteBuffer, importBreakPaths(file))

	// write output to file
	outputFilePath := path.Join(outputDir, packageName+".go")
	if err := ioutil.WriteFile(outputFilePath, outputWithSpaces, 0644); err != nil {
		return errors.Wrapf(err, "failed to write output to path: %s", outputFilePath)
	}

	return nil
}
